(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{"./node_modules/@graphiql/react/dist/Range.es.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return CharacterStream})),__webpack_require__.d(__webpack_exports__,"b",(function(){return Position})),__webpack_require__.d(__webpack_exports__,"c",(function(){return Range}));var __defProp=Object.defineProperty,__name=(target,value)=>__defProp(target,"name",{value:value,configurable:!0});class CharacterStream{constructor(sourceText){this.getStartOfToken=()=>this._start,this.getCurrentPosition=()=>this._pos,this.eol=()=>this._sourceText.length===this._pos,this.sol=()=>0===this._pos,this.peek=()=>this._sourceText.charAt(this._pos)?this._sourceText.charAt(this._pos):null,this.next=()=>{const char=this._sourceText.charAt(this._pos);return this._pos++,char},this.eat=pattern=>{if(this._testNextCharacter(pattern))return this._start=this._pos,this._pos++,this._sourceText.charAt(this._pos-1)},this.eatWhile=match=>{let isMatched=this._testNextCharacter(match),didEat=!1;for(isMatched&&(didEat=isMatched,this._start=this._pos);isMatched;)this._pos++,isMatched=this._testNextCharacter(match),didEat=!0;return didEat},this.eatSpace=()=>this.eatWhile(/[\s\u00a0]/),this.skipToEnd=()=>{this._pos=this._sourceText.length},this.skipTo=position=>{this._pos=position},this.match=(pattern,consume=!0,caseFold=!1)=>{let token=null,match=null;if("string"==typeof pattern){match=new RegExp(pattern,caseFold?"i":"g").test(this._sourceText.substr(this._pos,pattern.length)),token=pattern}else pattern instanceof RegExp&&(match=this._sourceText.slice(this._pos).match(pattern),token=null==match?void 0:match[0]);return!(null==match||!("string"==typeof pattern||match instanceof Array&&this._sourceText.startsWith(match[0],this._pos)))&&(consume&&(this._start=this._pos,token&&token.length&&(this._pos+=token.length)),match)},this.backUp=num=>{this._pos-=num},this.column=()=>this._pos,this.indentation=()=>{const match=this._sourceText.match(/\s*/);let indent=0;if(match&&0!==match.length){const whitespaces=match[0];let pos=0;for(;whitespaces.length>pos;)9===whitespaces.charCodeAt(pos)?indent+=2:indent++,pos++}return indent},this.current=()=>this._sourceText.slice(this._start,this._pos),this._start=0,this._pos=0,this._sourceText=sourceText}_testNextCharacter(pattern){const character=this._sourceText.charAt(this._pos);let isMatched=!1;return isMatched="string"==typeof pattern?character===pattern:pattern instanceof RegExp?pattern.test(character):pattern(character),isMatched}}__name(CharacterStream,"CharacterStream");class Range{constructor(start,end){this.containsPosition=position=>this.start.line===position.line?this.start.character<=position.character:this.end.line===position.line?this.end.character>=position.character:this.start.line<=position.line&&this.end.line>=position.line,this.start=start,this.end=end}setStart(line,character){this.start=new Position(line,character)}setEnd(line,character){this.end=new Position(line,character)}}__name(Range,"Range");class Position{constructor(line,character){this.lessThanOrEqualTo=position=>this.line<position.line||this.line===position.line&&this.character<=position.character,this.line=line,this.character=character}setLine(line){this.line=line}setCharacter(character){this.character=character}}__name(Position,"Position")},"./node_modules/@graphiql/react/dist/lint.es.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);var codemirror_es=__webpack_require__("./node_modules/@graphiql/react/dist/codemirror.es.js"),GraphQLError=__webpack_require__("./node_modules/graphql/error/GraphQLError.mjs");function LoneSchemaDefinitionRule(context){var _ref,_ref2,_oldSchema$astNode;const oldSchema=context.getSchema(),alreadyDefined=null!==(_ref=null!==(_ref2=null!==(_oldSchema$astNode=null==oldSchema?void 0:oldSchema.astNode)&&void 0!==_oldSchema$astNode?_oldSchema$astNode:null==oldSchema?void 0:oldSchema.getQueryType())&&void 0!==_ref2?_ref2:null==oldSchema?void 0:oldSchema.getMutationType())&&void 0!==_ref?_ref:null==oldSchema?void 0:oldSchema.getSubscriptionType();let schemaDefinitionsCount=0;return{SchemaDefinition(node){alreadyDefined?context.reportError(new GraphQLError.a("Cannot define a new schema within a schema extension.",{nodes:node})):(schemaDefinitionsCount>0&&context.reportError(new GraphQLError.a("Must provide only one schema definition.",{nodes:node})),++schemaDefinitionsCount)}}}function UniqueOperationTypesRule(context){const schema=context.getSchema(),definedOperationTypes=Object.create(null),existingOperationTypes=schema?{query:schema.getQueryType(),mutation:schema.getMutationType(),subscription:schema.getSubscriptionType()}:{};return{SchemaDefinition:checkOperationTypes,SchemaExtension:checkOperationTypes};function checkOperationTypes(node){var _node$operationTypes;const operationTypesNodes=null!==(_node$operationTypes=node.operationTypes)&&void 0!==_node$operationTypes?_node$operationTypes:[];for(const operationType of operationTypesNodes){const operation=operationType.operation,alreadyDefinedOperationType=definedOperationTypes[operation];existingOperationTypes[operation]?context.reportError(new GraphQLError.a(`Type for ${operation} already defined in the schema. It cannot be redefined.`,{nodes:operationType})):alreadyDefinedOperationType?context.reportError(new GraphQLError.a(`There can be only one ${operation} type in schema.`,{nodes:[alreadyDefinedOperationType,operationType]})):definedOperationTypes[operation]=operationType}return!1}}function UniqueTypeNamesRule(context){const knownTypeNames=Object.create(null),schema=context.getSchema();return{ScalarTypeDefinition:checkTypeName,ObjectTypeDefinition:checkTypeName,InterfaceTypeDefinition:checkTypeName,UnionTypeDefinition:checkTypeName,EnumTypeDefinition:checkTypeName,InputObjectTypeDefinition:checkTypeName};function checkTypeName(node){const typeName=node.name.value;if(null==schema||!schema.getType(typeName))return knownTypeNames[typeName]?context.reportError(new GraphQLError.a(`There can be only one type named "${typeName}".`,{nodes:[knownTypeNames[typeName],node.name]})):knownTypeNames[typeName]=node.name,!1;context.reportError(new GraphQLError.a(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,{nodes:node.name}))}}var type_definition=__webpack_require__("./node_modules/graphql/type/definition.mjs");function UniqueEnumValueNamesRule(context){const schema=context.getSchema(),existingTypeMap=schema?schema.getTypeMap():Object.create(null),knownValueNames=Object.create(null);return{EnumTypeDefinition:checkValueUniqueness,EnumTypeExtension:checkValueUniqueness};function checkValueUniqueness(node){var _node$values;const typeName=node.name.value;knownValueNames[typeName]||(knownValueNames[typeName]=Object.create(null));const valueNodes=null!==(_node$values=node.values)&&void 0!==_node$values?_node$values:[],valueNames=knownValueNames[typeName];for(const valueDef of valueNodes){const valueName=valueDef.name.value,existingType=existingTypeMap[typeName];Object(type_definition.s)(existingType)&&existingType.getValue(valueName)?context.reportError(new GraphQLError.a(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:valueDef.name})):valueNames[valueName]?context.reportError(new GraphQLError.a(`Enum value "${typeName}.${valueName}" can only be defined once.`,{nodes:[valueNames[valueName],valueDef.name]})):valueNames[valueName]=valueDef.name}return!1}}function UniqueFieldDefinitionNamesRule(context){const schema=context.getSchema(),existingTypeMap=schema?schema.getTypeMap():Object.create(null),knownFieldNames=Object.create(null);return{InputObjectTypeDefinition:checkFieldUniqueness,InputObjectTypeExtension:checkFieldUniqueness,InterfaceTypeDefinition:checkFieldUniqueness,InterfaceTypeExtension:checkFieldUniqueness,ObjectTypeDefinition:checkFieldUniqueness,ObjectTypeExtension:checkFieldUniqueness};function checkFieldUniqueness(node){var _node$fields;const typeName=node.name.value;knownFieldNames[typeName]||(knownFieldNames[typeName]=Object.create(null));const fieldNodes=null!==(_node$fields=node.fields)&&void 0!==_node$fields?_node$fields:[],fieldNames=knownFieldNames[typeName];for(const fieldDef of fieldNodes){const fieldName=fieldDef.name.value;hasField(existingTypeMap[typeName],fieldName)?context.reportError(new GraphQLError.a(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:fieldDef.name})):fieldNames[fieldName]?context.reportError(new GraphQLError.a(`Field "${typeName}.${fieldName}" can only be defined once.`,{nodes:[fieldNames[fieldName],fieldDef.name]})):fieldNames[fieldName]=fieldDef.name}return!1}}function hasField(type,fieldName){return!!(Object(type_definition.A)(type)||Object(type_definition.v)(type)||Object(type_definition.t)(type))&&null!=type.getFields()[fieldName]}function UniqueDirectiveNamesRule(context){const knownDirectiveNames=Object.create(null),schema=context.getSchema();return{DirectiveDefinition(node){const directiveName=node.name.value;if(null==schema||!schema.getDirective(directiveName))return knownDirectiveNames[directiveName]?context.reportError(new GraphQLError.a(`There can be only one directive named "@${directiveName}".`,{nodes:[knownDirectiveNames[directiveName],node.name]})):knownDirectiveNames[directiveName]=node.name,!1;context.reportError(new GraphQLError.a(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,{nodes:node.name}))}}}var didYouMean=__webpack_require__("./node_modules/graphql/jsutils/didYouMean.mjs"),suggestionList=__webpack_require__("./node_modules/graphql/jsutils/suggestionList.mjs"),kinds=__webpack_require__("./node_modules/graphql/language/kinds.mjs");function isExecutableDefinitionNode(node){return node.kind===kinds.a.OPERATION_DEFINITION||node.kind===kinds.a.FRAGMENT_DEFINITION}function isTypeSystemDefinitionNode(node){return node.kind===kinds.a.SCHEMA_DEFINITION||isTypeDefinitionNode(node)||node.kind===kinds.a.DIRECTIVE_DEFINITION}function isTypeDefinitionNode(node){return node.kind===kinds.a.SCALAR_TYPE_DEFINITION||node.kind===kinds.a.OBJECT_TYPE_DEFINITION||node.kind===kinds.a.INTERFACE_TYPE_DEFINITION||node.kind===kinds.a.UNION_TYPE_DEFINITION||node.kind===kinds.a.ENUM_TYPE_DEFINITION||node.kind===kinds.a.INPUT_OBJECT_TYPE_DEFINITION}function isTypeSystemExtensionNode(node){return node.kind===kinds.a.SCHEMA_EXTENSION||isTypeExtensionNode(node)}function isTypeExtensionNode(node){return node.kind===kinds.a.SCALAR_TYPE_EXTENSION||node.kind===kinds.a.OBJECT_TYPE_EXTENSION||node.kind===kinds.a.INTERFACE_TYPE_EXTENSION||node.kind===kinds.a.UNION_TYPE_EXTENSION||node.kind===kinds.a.ENUM_TYPE_EXTENSION||node.kind===kinds.a.INPUT_OBJECT_TYPE_EXTENSION}var introspection=__webpack_require__("./node_modules/graphql/type/introspection.mjs");function KnownTypeNamesRule(context){const schema=context.getSchema(),existingTypesMap=schema?schema.getTypeMap():Object.create(null),definedTypes=Object.create(null);for(const def of context.getDocument().definitions)isTypeDefinitionNode(def)&&(definedTypes[def.name.value]=!0);const typeNames=[...Object.keys(existingTypesMap),...Object.keys(definedTypes)];return{NamedType(node,_1,parent,_2,ancestors){const typeName=node.name.value;if(!existingTypesMap[typeName]&&!definedTypes[typeName]){var _ancestors$;const definitionNode=null!==(_ancestors$=ancestors[2])&&void 0!==_ancestors$?_ancestors$:parent,isSDL=null!=definitionNode&&function isSDLNode(value){return"kind"in value&&(isTypeSystemDefinitionNode(value)||isTypeSystemExtensionNode(value))}(definitionNode);if(isSDL&&standardTypeNames.includes(typeName))return;const suggestedTypes=Object(suggestionList.a)(typeName,isSDL?standardTypeNames.concat(typeNames):typeNames);context.reportError(new GraphQLError.a(`Unknown type "${typeName}".`+Object(didYouMean.a)(suggestedTypes),{nodes:node}))}}}}const standardTypeNames=[...__webpack_require__("./node_modules/graphql/type/scalars.mjs").e,...introspection.f].map((type=>type.name));var inspect=__webpack_require__("./node_modules/graphql/jsutils/inspect.mjs"),invariant=__webpack_require__("./node_modules/graphql/jsutils/invariant.mjs"),language_ast=__webpack_require__("./node_modules/graphql/language/ast.mjs"),directiveLocation=__webpack_require__("./node_modules/graphql/language/directiveLocation.mjs"),directives=__webpack_require__("./node_modules/graphql/type/directives.mjs");function KnownDirectivesRule(context){const locationsMap=Object.create(null),schema=context.getSchema(),definedDirectives=schema?schema.getDirectives():directives.f;for(const directive of definedDirectives)locationsMap[directive.name]=directive.locations;const astDefinitions=context.getDocument().definitions;for(const def of astDefinitions)def.kind===kinds.a.DIRECTIVE_DEFINITION&&(locationsMap[def.name.value]=def.locations.map((name=>name.value)));return{Directive(node,_key,_parent,_path,ancestors){const name=node.name.value,locations=locationsMap[name];if(!locations)return void context.reportError(new GraphQLError.a(`Unknown directive "@${name}".`,{nodes:node}));const candidateLocation=function getDirectiveLocationForASTPath(ancestors){const appliedTo=ancestors[ancestors.length-1];switch("kind"in appliedTo||Object(invariant.a)(!1),appliedTo.kind){case kinds.a.OPERATION_DEFINITION:return function getDirectiveLocationForOperation(operation){switch(operation){case language_ast.b.QUERY:return directiveLocation.a.QUERY;case language_ast.b.MUTATION:return directiveLocation.a.MUTATION;case language_ast.b.SUBSCRIPTION:return directiveLocation.a.SUBSCRIPTION}}(appliedTo.operation);case kinds.a.FIELD:return directiveLocation.a.FIELD;case kinds.a.FRAGMENT_SPREAD:return directiveLocation.a.FRAGMENT_SPREAD;case kinds.a.INLINE_FRAGMENT:return directiveLocation.a.INLINE_FRAGMENT;case kinds.a.FRAGMENT_DEFINITION:return directiveLocation.a.FRAGMENT_DEFINITION;case kinds.a.VARIABLE_DEFINITION:return directiveLocation.a.VARIABLE_DEFINITION;case kinds.a.SCHEMA_DEFINITION:case kinds.a.SCHEMA_EXTENSION:return directiveLocation.a.SCHEMA;case kinds.a.SCALAR_TYPE_DEFINITION:case kinds.a.SCALAR_TYPE_EXTENSION:return directiveLocation.a.SCALAR;case kinds.a.OBJECT_TYPE_DEFINITION:case kinds.a.OBJECT_TYPE_EXTENSION:return directiveLocation.a.OBJECT;case kinds.a.FIELD_DEFINITION:return directiveLocation.a.FIELD_DEFINITION;case kinds.a.INTERFACE_TYPE_DEFINITION:case kinds.a.INTERFACE_TYPE_EXTENSION:return directiveLocation.a.INTERFACE;case kinds.a.UNION_TYPE_DEFINITION:case kinds.a.UNION_TYPE_EXTENSION:return directiveLocation.a.UNION;case kinds.a.ENUM_TYPE_DEFINITION:case kinds.a.ENUM_TYPE_EXTENSION:return directiveLocation.a.ENUM;case kinds.a.ENUM_VALUE_DEFINITION:return directiveLocation.a.ENUM_VALUE;case kinds.a.INPUT_OBJECT_TYPE_DEFINITION:case kinds.a.INPUT_OBJECT_TYPE_EXTENSION:return directiveLocation.a.INPUT_OBJECT;case kinds.a.INPUT_VALUE_DEFINITION:{const parentNode=ancestors[ancestors.length-3];return"kind"in parentNode||Object(invariant.a)(!1),parentNode.kind===kinds.a.INPUT_OBJECT_TYPE_DEFINITION?directiveLocation.a.INPUT_FIELD_DEFINITION:directiveLocation.a.ARGUMENT_DEFINITION}default:Object(invariant.a)(!1,"Unexpected kind: "+Object(inspect.a)(appliedTo.kind))}}(ancestors);candidateLocation&&!locations.includes(candidateLocation)&&context.reportError(new GraphQLError.a(`Directive "@${name}" may not be used on ${candidateLocation}.`,{nodes:node}))}}}function UniqueDirectivesPerLocationRule(context){const uniqueDirectiveMap=Object.create(null),schema=context.getSchema(),definedDirectives=schema?schema.getDirectives():directives.f;for(const directive of definedDirectives)uniqueDirectiveMap[directive.name]=!directive.isRepeatable;const astDefinitions=context.getDocument().definitions;for(const def of astDefinitions)def.kind===kinds.a.DIRECTIVE_DEFINITION&&(uniqueDirectiveMap[def.name.value]=!def.repeatable);const schemaDirectives=Object.create(null),typeDirectivesMap=Object.create(null);return{enter(node){if(!("directives"in node)||!node.directives)return;let seenDirectives;if(node.kind===kinds.a.SCHEMA_DEFINITION||node.kind===kinds.a.SCHEMA_EXTENSION)seenDirectives=schemaDirectives;else if(isTypeDefinitionNode(node)||isTypeExtensionNode(node)){const typeName=node.name.value;seenDirectives=typeDirectivesMap[typeName],void 0===seenDirectives&&(typeDirectivesMap[typeName]=seenDirectives=Object.create(null))}else seenDirectives=Object.create(null);for(const directive of node.directives){const directiveName=directive.name.value;uniqueDirectiveMap[directiveName]&&(seenDirectives[directiveName]?context.reportError(new GraphQLError.a(`The directive "@${directiveName}" can only be used once at this location.`,{nodes:[seenDirectives[directiveName],directive]})):seenDirectives[directiveName]=directive)}}}}function PossibleTypeExtensionsRule(context){const schema=context.getSchema(),definedTypes=Object.create(null);for(const def of context.getDocument().definitions)isTypeDefinitionNode(def)&&(definedTypes[def.name.value]=def);return{ScalarTypeExtension:checkExtension,ObjectTypeExtension:checkExtension,InterfaceTypeExtension:checkExtension,UnionTypeExtension:checkExtension,EnumTypeExtension:checkExtension,InputObjectTypeExtension:checkExtension};function checkExtension(node){const typeName=node.name.value,defNode=definedTypes[typeName],existingType=null==schema?void 0:schema.getType(typeName);let expectedKind;if(defNode?expectedKind=defKindToExtKind[defNode.kind]:existingType&&(expectedKind=function typeToExtKind(type){if(Object(type_definition.E)(type))return kinds.a.SCALAR_TYPE_EXTENSION;if(Object(type_definition.A)(type))return kinds.a.OBJECT_TYPE_EXTENSION;if(Object(type_definition.v)(type))return kinds.a.INTERFACE_TYPE_EXTENSION;if(Object(type_definition.G)(type))return kinds.a.UNION_TYPE_EXTENSION;if(Object(type_definition.s)(type))return kinds.a.ENUM_TYPE_EXTENSION;if(Object(type_definition.t)(type))return kinds.a.INPUT_OBJECT_TYPE_EXTENSION;Object(invariant.a)(!1,"Unexpected type: "+Object(inspect.a)(type))}(existingType)),expectedKind){if(expectedKind!==node.kind){const kindStr=function extensionKindToTypeName(kind){switch(kind){case kinds.a.SCALAR_TYPE_EXTENSION:return"scalar";case kinds.a.OBJECT_TYPE_EXTENSION:return"object";case kinds.a.INTERFACE_TYPE_EXTENSION:return"interface";case kinds.a.UNION_TYPE_EXTENSION:return"union";case kinds.a.ENUM_TYPE_EXTENSION:return"enum";case kinds.a.INPUT_OBJECT_TYPE_EXTENSION:return"input object";default:Object(invariant.a)(!1,"Unexpected kind: "+Object(inspect.a)(kind))}}(node.kind);context.reportError(new GraphQLError.a(`Cannot extend non-${kindStr} type "${typeName}".`,{nodes:defNode?[defNode,node]:node}))}}else{const allTypeNames=Object.keys({...definedTypes,...null==schema?void 0:schema.getTypeMap()}),suggestedTypes=Object(suggestionList.a)(typeName,allTypeNames);context.reportError(new GraphQLError.a(`Cannot extend type "${typeName}" because it is not defined.`+Object(didYouMean.a)(suggestedTypes),{nodes:node.name}))}}}const defKindToExtKind={[kinds.a.SCALAR_TYPE_DEFINITION]:kinds.a.SCALAR_TYPE_EXTENSION,[kinds.a.OBJECT_TYPE_DEFINITION]:kinds.a.OBJECT_TYPE_EXTENSION,[kinds.a.INTERFACE_TYPE_DEFINITION]:kinds.a.INTERFACE_TYPE_EXTENSION,[kinds.a.UNION_TYPE_DEFINITION]:kinds.a.UNION_TYPE_EXTENSION,[kinds.a.ENUM_TYPE_DEFINITION]:kinds.a.ENUM_TYPE_EXTENSION,[kinds.a.INPUT_OBJECT_TYPE_DEFINITION]:kinds.a.INPUT_OBJECT_TYPE_EXTENSION};function groupBy(list,keyFn){const result=new Map;for(const item of list){const key=keyFn(item),group=result.get(key);void 0===group?result.set(key,[item]):group.push(item)}return result}function UniqueArgumentNamesRule(context){return{Field:checkArgUniqueness,Directive:checkArgUniqueness};function checkArgUniqueness(parentNode){var _parentNode$arguments;const seenArgs=groupBy(null!==(_parentNode$arguments=parentNode.arguments)&&void 0!==_parentNode$arguments?_parentNode$arguments:[],(arg=>arg.name.value));for(const[argName,argNodes]of seenArgs)argNodes.length>1&&context.reportError(new GraphQLError.a(`There can be only one argument named "${argName}".`,{nodes:argNodes.map((node=>node.name))}))}}function UniqueInputFieldNamesRule(context){const knownNameStack=[];let knownNames=Object.create(null);return{ObjectValue:{enter(){knownNameStack.push(knownNames),knownNames=Object.create(null)},leave(){const prevKnownNames=knownNameStack.pop();prevKnownNames||Object(invariant.a)(!1),knownNames=prevKnownNames}},ObjectField(node){const fieldName=node.name.value;knownNames[fieldName]?context.reportError(new GraphQLError.a(`There can be only one input field named "${fieldName}".`,{nodes:[knownNames[fieldName],node.name]})):knownNames[fieldName]=node.name}}}function ExecutableDefinitionsRule(context){return{Document(node){for(const definition of node.definitions)if(!isExecutableDefinitionNode(definition)){const defName=definition.kind===kinds.a.SCHEMA_DEFINITION||definition.kind===kinds.a.SCHEMA_EXTENSION?"schema":'"'+definition.name.value+'"';context.reportError(new GraphQLError.a(`The ${defName} definition is not executable.`,{nodes:definition}))}return!1}}}var naturalCompare=__webpack_require__("./node_modules/graphql/jsutils/naturalCompare.mjs");var printer=__webpack_require__("./node_modules/graphql/language/printer.mjs"),typeFromAST=__webpack_require__("./node_modules/graphql/utilities/typeFromAST.mjs");function KnownArgumentNamesOnDirectivesRule(context){const directiveArgs=Object.create(null),schema=context.getSchema(),definedDirectives=schema?schema.getDirectives():directives.f;for(const directive of definedDirectives)directiveArgs[directive.name]=directive.args.map((arg=>arg.name));const astDefinitions=context.getDocument().definitions;for(const def of astDefinitions)if(def.kind===kinds.a.DIRECTIVE_DEFINITION){var _def$arguments;const argsNodes=null!==(_def$arguments=def.arguments)&&void 0!==_def$arguments?_def$arguments:[];directiveArgs[def.name.value]=argsNodes.map((arg=>arg.name.value))}return{Directive(directiveNode){const directiveName=directiveNode.name.value,knownArgs=directiveArgs[directiveName];if(directiveNode.arguments&&knownArgs)for(const argNode of directiveNode.arguments){const argName=argNode.name.value;if(!knownArgs.includes(argName)){const suggestions=Object(suggestionList.a)(argName,knownArgs);context.reportError(new GraphQLError.a(`Unknown argument "${argName}" on directive "@${directiveName}".`+Object(didYouMean.a)(suggestions),{nodes:argNode}))}}return!1}}}function KnownFragmentNamesRule(context){return{FragmentSpread(node){const fragmentName=node.name.value;context.getFragment(fragmentName)||context.reportError(new GraphQLError.a(`Unknown fragment "${fragmentName}".`,{nodes:node.name}))}}}function NoUnusedFragmentsRule(context){const operationDefs=[],fragmentDefs=[];return{OperationDefinition:node=>(operationDefs.push(node),!1),FragmentDefinition:node=>(fragmentDefs.push(node),!1),Document:{leave(){const fragmentNameUsed=Object.create(null);for(const operation of operationDefs)for(const fragment of context.getRecursivelyReferencedFragments(operation))fragmentNameUsed[fragment.name.value]=!0;for(const fragmentDef of fragmentDefs){const fragName=fragmentDef.name.value;!0!==fragmentNameUsed[fragName]&&context.reportError(new GraphQLError.a(`Fragment "${fragName}" is never used.`,{nodes:fragmentDef}))}}}}}function sortValueNode(valueNode){switch(valueNode.kind){case kinds.a.OBJECT:return{...valueNode,fields:(fields=valueNode.fields,fields.map((fieldNode=>({...fieldNode,value:sortValueNode(fieldNode.value)}))).sort(((fieldA,fieldB)=>Object(naturalCompare.a)(fieldA.name.value,fieldB.name.value))))};case kinds.a.LIST:return{...valueNode,values:valueNode.values.map(sortValueNode)};case kinds.a.INT:case kinds.a.FLOAT:case kinds.a.STRING:case kinds.a.BOOLEAN:case kinds.a.NULL:case kinds.a.ENUM:case kinds.a.VARIABLE:return valueNode}var fields}function reasonMessage(reason){return Array.isArray(reason)?reason.map((([responseName,subReason])=>`subfields "${responseName}" conflict because `+reasonMessage(subReason))).join(" and "):reason}function collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,fragmentName){const fragment=context.getFragment(fragmentName);if(!fragment)return;const[fieldMap2,referencedFragmentNames]=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment);if(fieldMap!==fieldMap2){collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,fieldMap2);for(const referencedFragmentName of referencedFragmentNames)comparedFragmentPairs.has(referencedFragmentName,fragmentName,areMutuallyExclusive)||(comparedFragmentPairs.add(referencedFragmentName,fragmentName,areMutuallyExclusive),collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap,referencedFragmentName))}}function collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentName1,fragmentName2){if(fragmentName1===fragmentName2)return;if(comparedFragmentPairs.has(fragmentName1,fragmentName2,areMutuallyExclusive))return;comparedFragmentPairs.add(fragmentName1,fragmentName2,areMutuallyExclusive);const fragment1=context.getFragment(fragmentName1),fragment2=context.getFragment(fragmentName2);if(!fragment1||!fragment2)return;const[fieldMap1,referencedFragmentNames1]=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment1),[fieldMap2,referencedFragmentNames2]=getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment2);collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap1,fieldMap2);for(const referencedFragmentName2 of referencedFragmentNames2)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentName1,referencedFragmentName2);for(const referencedFragmentName1 of referencedFragmentNames1)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,referencedFragmentName1,fragmentName2)}function collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,fieldMap1,fieldMap2){for(const[responseName,fields1]of Object.entries(fieldMap1)){const fields2=fieldMap2[responseName];if(fields2)for(const field1 of fields1)for(const field2 of fields2){const conflict=findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,responseName,field1,field2);conflict&&conflicts.push(conflict)}}}function findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentFieldsAreMutuallyExclusive,responseName,field1,field2){const[parentType1,node1,def1]=field1,[parentType2,node2,def2]=field2,areMutuallyExclusive=parentFieldsAreMutuallyExclusive||parentType1!==parentType2&&Object(type_definition.A)(parentType1)&&Object(type_definition.A)(parentType2);if(!areMutuallyExclusive){const name1=node1.name.value,name2=node2.name.value;if(name1!==name2)return[[responseName,`"${name1}" and "${name2}" are different fields`],[node1],[node2]];if(stringifyArguments(node1)!==stringifyArguments(node2))return[[responseName,"they have differing arguments"],[node1],[node2]]}const type1=null==def1?void 0:def1.type,type2=null==def2?void 0:def2.type;if(type1&&type2&&doTypesConflict(type1,type2))return[[responseName,`they return conflicting types "${Object(inspect.a)(type1)}" and "${Object(inspect.a)(type2)}"`],[node1],[node2]];const selectionSet1=node1.selectionSet,selectionSet2=node2.selectionSet;if(selectionSet1&&selectionSet2){const conflicts=function findConflictsBetweenSubSelectionSets(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,parentType1,selectionSet1,parentType2,selectionSet2){const conflicts=[],[fieldMap1,fragmentNames1]=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType1,selectionSet1),[fieldMap2,fragmentNames2]=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType2,selectionSet2);collectConflictsBetween(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap1,fieldMap2);for(const fragmentName2 of fragmentNames2)collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap1,fragmentName2);for(const fragmentName1 of fragmentNames1)collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fieldMap2,fragmentName1);for(const fragmentName1 of fragmentNames1)for(const fragmentName2 of fragmentNames2)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,fragmentName1,fragmentName2);return conflicts}(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,areMutuallyExclusive,Object(type_definition.o)(type1),selectionSet1,Object(type_definition.o)(type2),selectionSet2);return function subfieldConflicts(conflicts,responseName,node1,node2){if(conflicts.length>0)return[[responseName,conflicts.map((([reason])=>reason))],[node1,...conflicts.map((([,fields1])=>fields1)).flat()],[node2,...conflicts.map((([,,fields2])=>fields2)).flat()]]}(conflicts,responseName,node1,node2)}}function stringifyArguments(fieldNode){var _fieldNode$arguments;const args=null!==(_fieldNode$arguments=fieldNode.arguments)&&void 0!==_fieldNode$arguments?_fieldNode$arguments:[],inputObjectWithArgs={kind:kinds.a.OBJECT,fields:args.map((argNode=>({kind:kinds.a.OBJECT_FIELD,name:argNode.name,value:argNode.value})))};return Object(printer.a)(sortValueNode(inputObjectWithArgs))}function doTypesConflict(type1,type2){return Object(type_definition.x)(type1)?!Object(type_definition.x)(type2)||doTypesConflict(type1.ofType,type2.ofType):!!Object(type_definition.x)(type2)||(Object(type_definition.z)(type1)?!Object(type_definition.z)(type2)||doTypesConflict(type1.ofType,type2.ofType):!!Object(type_definition.z)(type2)||!(!Object(type_definition.w)(type1)&&!Object(type_definition.w)(type2))&&type1!==type2)}function getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType,selectionSet){const cached=cachedFieldsAndFragmentNames.get(selectionSet);if(cached)return cached;const nodeAndDefs=Object.create(null),fragmentNames=Object.create(null);_collectFieldsAndFragmentNames(context,parentType,selectionSet,nodeAndDefs,fragmentNames);const result=[nodeAndDefs,Object.keys(fragmentNames)];return cachedFieldsAndFragmentNames.set(selectionSet,result),result}function getReferencedFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragment){const cached=cachedFieldsAndFragmentNames.get(fragment.selectionSet);if(cached)return cached;const fragmentType=Object(typeFromAST.a)(context.getSchema(),fragment.typeCondition);return getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,fragmentType,fragment.selectionSet)}function _collectFieldsAndFragmentNames(context,parentType,selectionSet,nodeAndDefs,fragmentNames){for(const selection of selectionSet.selections)switch(selection.kind){case kinds.a.FIELD:{const fieldName=selection.name.value;let fieldDef;(Object(type_definition.A)(parentType)||Object(type_definition.v)(parentType))&&(fieldDef=parentType.getFields()[fieldName]);const responseName=selection.alias?selection.alias.value:fieldName;nodeAndDefs[responseName]||(nodeAndDefs[responseName]=[]),nodeAndDefs[responseName].push([parentType,selection,fieldDef]);break}case kinds.a.FRAGMENT_SPREAD:fragmentNames[selection.name.value]=!0;break;case kinds.a.INLINE_FRAGMENT:{const typeCondition=selection.typeCondition,inlineFragmentType=typeCondition?Object(typeFromAST.a)(context.getSchema(),typeCondition):parentType;_collectFieldsAndFragmentNames(context,inlineFragmentType,selection.selectionSet,nodeAndDefs,fragmentNames);break}}}class PairSet{constructor(){this._data=new Map}has(a,b,areMutuallyExclusive){var _this$_data$get;const[key1,key2]=a<b?[a,b]:[b,a],result=null===(_this$_data$get=this._data.get(key1))||void 0===_this$_data$get?void 0:_this$_data$get.get(key2);return void 0!==result&&(!!areMutuallyExclusive||areMutuallyExclusive===result)}add(a,b,areMutuallyExclusive){const[key1,key2]=a<b?[a,b]:[b,a],map=this._data.get(key1);void 0===map?this._data.set(key1,new Map([[key2,areMutuallyExclusive]])):map.set(key2,areMutuallyExclusive)}}var typeComparators=__webpack_require__("./node_modules/graphql/utilities/typeComparators.mjs");var keyMap=__webpack_require__("./node_modules/graphql/jsutils/keyMap.mjs");function ProvidedRequiredArgumentsOnDirectivesRule(context){var _schema$getDirectives;const requiredArgsMap=Object.create(null),schema=context.getSchema(),definedDirectives=null!==(_schema$getDirectives=null==schema?void 0:schema.getDirectives())&&void 0!==_schema$getDirectives?_schema$getDirectives:directives.f;for(const directive of definedDirectives)requiredArgsMap[directive.name]=Object(keyMap.a)(directive.args.filter(type_definition.C),(arg=>arg.name));const astDefinitions=context.getDocument().definitions;for(const def of astDefinitions)if(def.kind===kinds.a.DIRECTIVE_DEFINITION){var _def$arguments;const argNodes=null!==(_def$arguments=def.arguments)&&void 0!==_def$arguments?_def$arguments:[];requiredArgsMap[def.name.value]=Object(keyMap.a)(argNodes.filter(isRequiredArgumentNode),(arg=>arg.name.value))}return{Directive:{leave(directiveNode){const directiveName=directiveNode.name.value,requiredArgs=requiredArgsMap[directiveName];if(requiredArgs){var _directiveNode$argume;const argNodes=null!==(_directiveNode$argume=directiveNode.arguments)&&void 0!==_directiveNode$argume?_directiveNode$argume:[],argNodeMap=new Set(argNodes.map((arg=>arg.name.value)));for(const[argName,argDef]of Object.entries(requiredArgs))if(!argNodeMap.has(argName)){const argType=Object(type_definition.F)(argDef.type)?Object(inspect.a)(argDef.type):Object(printer.a)(argDef.type);context.reportError(new GraphQLError.a(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,{nodes:directiveNode}))}}}}}}function isRequiredArgumentNode(arg){return arg.type.kind===kinds.a.NON_NULL_TYPE&&null==arg.defaultValue}__webpack_require__("./node_modules/graphql/jsutils/isIterableObject.mjs"),__webpack_require__("./node_modules/graphql/jsutils/isObjectLike.mjs");var valueFromAST=__webpack_require__("./node_modules/graphql/utilities/valueFromAST.mjs");function getDirectiveValues(directiveDef,node,variableValues){var _node$directives;const directiveNode=null===(_node$directives=node.directives)||void 0===_node$directives?void 0:_node$directives.find((directive=>directive.name.value===directiveDef.name));if(directiveNode)return function getArgumentValues(def,node,variableValues){var _node$arguments;const coercedValues={},argumentNodes=null!==(_node$arguments=node.arguments)&&void 0!==_node$arguments?_node$arguments:[],argNodeMap=Object(keyMap.a)(argumentNodes,(arg=>arg.name.value));for(const argDef of def.args){const name=argDef.name,argType=argDef.type,argumentNode=argNodeMap[name];if(!argumentNode){if(void 0!==argDef.defaultValue)coercedValues[name]=argDef.defaultValue;else if(Object(type_definition.z)(argType))throw new GraphQLError.a(`Argument "${name}" of required type "${Object(inspect.a)(argType)}" was not provided.`,{nodes:node});continue}const valueNode=argumentNode.value;let isNull=valueNode.kind===kinds.a.NULL;if(valueNode.kind===kinds.a.VARIABLE){const variableName=valueNode.name.value;if(null==variableValues||!values_hasOwnProperty(variableValues,variableName)){if(void 0!==argDef.defaultValue)coercedValues[name]=argDef.defaultValue;else if(Object(type_definition.z)(argType))throw new GraphQLError.a(`Argument "${name}" of required type "${Object(inspect.a)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,{nodes:valueNode});continue}isNull=null==variableValues[variableName]}if(isNull&&Object(type_definition.z)(argType))throw new GraphQLError.a(`Argument "${name}" of non-null type "${Object(inspect.a)(argType)}" must not be null.`,{nodes:valueNode});const coercedValue=Object(valueFromAST.a)(valueNode,argType,variableValues);if(void 0===coercedValue)throw new GraphQLError.a(`Argument "${name}" has invalid value ${Object(printer.a)(valueNode)}.`,{nodes:valueNode});coercedValues[name]=coercedValue}return coercedValues}(directiveDef,directiveNode,variableValues)}function values_hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop)}function collectFieldsImpl(schema,fragments,variableValues,runtimeType,selectionSet,fields,visitedFragmentNames){for(const selection of selectionSet.selections)switch(selection.kind){case kinds.a.FIELD:{if(!shouldIncludeNode(variableValues,selection))continue;const name=(node=selection).alias?node.alias.value:node.name.value,fieldList=fields.get(name);void 0!==fieldList?fieldList.push(selection):fields.set(name,[selection]);break}case kinds.a.INLINE_FRAGMENT:if(!shouldIncludeNode(variableValues,selection)||!doesFragmentConditionMatch(schema,selection,runtimeType))continue;collectFieldsImpl(schema,fragments,variableValues,runtimeType,selection.selectionSet,fields,visitedFragmentNames);break;case kinds.a.FRAGMENT_SPREAD:{const fragName=selection.name.value;if(visitedFragmentNames.has(fragName)||!shouldIncludeNode(variableValues,selection))continue;visitedFragmentNames.add(fragName);const fragment=fragments[fragName];if(!fragment||!doesFragmentConditionMatch(schema,fragment,runtimeType))continue;collectFieldsImpl(schema,fragments,variableValues,runtimeType,fragment.selectionSet,fields,visitedFragmentNames);break}}var node}function shouldIncludeNode(variableValues,node){const skip=getDirectiveValues(directives.d,node,variableValues);if(!0===(null==skip?void 0:skip.if))return!1;const include=getDirectiveValues(directives.c,node,variableValues);return!1!==(null==include?void 0:include.if)}function doesFragmentConditionMatch(schema,fragment,type){const typeConditionNode=fragment.typeCondition;if(!typeConditionNode)return!0;const conditionalType=Object(typeFromAST.a)(schema,typeConditionNode);return conditionalType===type||!!Object(type_definition.q)(conditionalType)&&schema.isSubType(conditionalType,type)}function isValidValueNode(context,node){const locationType=context.getInputType();if(!locationType)return;const type=Object(type_definition.o)(locationType);if(Object(type_definition.w)(type))try{if(void 0===type.parseLiteral(node,void 0)){const typeStr=Object(inspect.a)(locationType);context.reportError(new GraphQLError.a(`Expected value of type "${typeStr}", found ${Object(printer.a)(node)}.`,{nodes:node}))}}catch(error){const typeStr=Object(inspect.a)(locationType);error instanceof GraphQLError.a?context.reportError(error):context.reportError(new GraphQLError.a(`Expected value of type "${typeStr}", found ${Object(printer.a)(node)}; `+error.message,{nodes:node,originalError:error}))}else{const typeStr=Object(inspect.a)(locationType);context.reportError(new GraphQLError.a(`Expected value of type "${typeStr}", found ${Object(printer.a)(node)}.`,{nodes:node}))}}function allowedVariableUsage(schema,varType,varDefaultValue,locationType,locationDefaultValue){if(Object(type_definition.z)(locationType)&&!Object(type_definition.z)(varType)){const hasLocationDefaultValue=void 0!==locationDefaultValue;if(!(null!=varDefaultValue&&varDefaultValue.kind!==kinds.a.NULL)&&!hasLocationDefaultValue)return!1;const nullableLocationType=locationType.ofType;return Object(typeComparators.c)(schema,varType,nullableLocationType)}return Object(typeComparators.c)(schema,varType,locationType)}const specifiedRules=Object.freeze([ExecutableDefinitionsRule,function UniqueOperationNamesRule(context){const knownOperationNames=Object.create(null);return{OperationDefinition(node){const operationName=node.name;return operationName&&(knownOperationNames[operationName.value]?context.reportError(new GraphQLError.a(`There can be only one operation named "${operationName.value}".`,{nodes:[knownOperationNames[operationName.value],operationName]})):knownOperationNames[operationName.value]=operationName),!1},FragmentDefinition:()=>!1}},function LoneAnonymousOperationRule(context){let operationCount=0;return{Document(node){operationCount=node.definitions.filter((definition=>definition.kind===kinds.a.OPERATION_DEFINITION)).length},OperationDefinition(node){!node.name&&operationCount>1&&context.reportError(new GraphQLError.a("This anonymous operation must be the only defined operation.",{nodes:node}))}}},function SingleFieldSubscriptionsRule(context){return{OperationDefinition(node){if("subscription"===node.operation){const schema=context.getSchema(),subscriptionType=schema.getSubscriptionType();if(subscriptionType){const operationName=node.name?node.name.value:null,variableValues=Object.create(null),document=context.getDocument(),fragments=Object.create(null);for(const definition of document.definitions)definition.kind===kinds.a.FRAGMENT_DEFINITION&&(fragments[definition.name.value]=definition);const fields=function collectFields(schema,fragments,variableValues,runtimeType,selectionSet){const fields=new Map;return collectFieldsImpl(schema,fragments,variableValues,runtimeType,selectionSet,fields,new Set),fields}(schema,fragments,variableValues,subscriptionType,node.selectionSet);if(fields.size>1){const extraFieldSelections=[...fields.values()].slice(1).flat();context.reportError(new GraphQLError.a(null!=operationName?`Subscription "${operationName}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:extraFieldSelections}))}for(const fieldNodes of fields.values()){fieldNodes[0].name.value.startsWith("__")&&context.reportError(new GraphQLError.a(null!=operationName?`Subscription "${operationName}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:fieldNodes}))}}}}}},KnownTypeNamesRule,function FragmentsOnCompositeTypesRule(context){return{InlineFragment(node){const typeCondition=node.typeCondition;if(typeCondition){const type=Object(typeFromAST.a)(context.getSchema(),typeCondition);if(type&&!Object(type_definition.r)(type)){const typeStr=Object(printer.a)(typeCondition);context.reportError(new GraphQLError.a(`Fragment cannot condition on non composite type "${typeStr}".`,{nodes:typeCondition}))}}},FragmentDefinition(node){const type=Object(typeFromAST.a)(context.getSchema(),node.typeCondition);if(type&&!Object(type_definition.r)(type)){const typeStr=Object(printer.a)(node.typeCondition);context.reportError(new GraphQLError.a(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,{nodes:node.typeCondition}))}}}},function VariablesAreInputTypesRule(context){return{VariableDefinition(node){const type=Object(typeFromAST.a)(context.getSchema(),node.type);if(void 0!==type&&!Object(type_definition.u)(type)){const variableName=node.variable.name.value,typeName=Object(printer.a)(node.type);context.reportError(new GraphQLError.a(`Variable "$${variableName}" cannot be non-input type "${typeName}".`,{nodes:node.type}))}}}},function ScalarLeafsRule(context){return{Field(node){const type=context.getType(),selectionSet=node.selectionSet;if(type)if(Object(type_definition.w)(Object(type_definition.o)(type))){if(selectionSet){const fieldName=node.name.value,typeStr=Object(inspect.a)(type);context.reportError(new GraphQLError.a(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,{nodes:selectionSet}))}}else if(!selectionSet){const fieldName=node.name.value,typeStr=Object(inspect.a)(type);context.reportError(new GraphQLError.a(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,{nodes:node}))}}}},function FieldsOnCorrectTypeRule(context){return{Field(node){const type=context.getParentType();if(type){if(!context.getFieldDef()){const schema=context.getSchema(),fieldName=node.name.value;let suggestion=Object(didYouMean.a)("to use an inline fragment on",function getSuggestedTypeNames(schema,type,fieldName){if(!Object(type_definition.q)(type))return[];const suggestedTypes=new Set,usageCount=Object.create(null);for(const possibleType of schema.getPossibleTypes(type))if(possibleType.getFields()[fieldName]){suggestedTypes.add(possibleType),usageCount[possibleType.name]=1;for(const possibleInterface of possibleType.getInterfaces()){var _usageCount$possibleI;possibleInterface.getFields()[fieldName]&&(suggestedTypes.add(possibleInterface),usageCount[possibleInterface.name]=(null!==(_usageCount$possibleI=usageCount[possibleInterface.name])&&void 0!==_usageCount$possibleI?_usageCount$possibleI:0)+1)}}return[...suggestedTypes].sort(((typeA,typeB)=>{const usageCountDiff=usageCount[typeB.name]-usageCount[typeA.name];return 0!==usageCountDiff?usageCountDiff:Object(type_definition.v)(typeA)&&schema.isSubType(typeA,typeB)?-1:Object(type_definition.v)(typeB)&&schema.isSubType(typeB,typeA)?1:Object(naturalCompare.a)(typeA.name,typeB.name)})).map((x=>x.name))}(schema,type,fieldName));""===suggestion&&(suggestion=Object(didYouMean.a)(function getSuggestedFieldNames(type,fieldName){if(Object(type_definition.A)(type)||Object(type_definition.v)(type)){const possibleFieldNames=Object.keys(type.getFields());return Object(suggestionList.a)(fieldName,possibleFieldNames)}return[]}(type,fieldName))),context.reportError(new GraphQLError.a(`Cannot query field "${fieldName}" on type "${type.name}".`+suggestion,{nodes:node}))}}}}},function UniqueFragmentNamesRule(context){const knownFragmentNames=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(node){const fragmentName=node.name.value;return knownFragmentNames[fragmentName]?context.reportError(new GraphQLError.a(`There can be only one fragment named "${fragmentName}".`,{nodes:[knownFragmentNames[fragmentName],node.name]})):knownFragmentNames[fragmentName]=node.name,!1}}},KnownFragmentNamesRule,NoUnusedFragmentsRule,function PossibleFragmentSpreadsRule(context){return{InlineFragment(node){const fragType=context.getType(),parentType=context.getParentType();if(Object(type_definition.r)(fragType)&&Object(type_definition.r)(parentType)&&!Object(typeComparators.a)(context.getSchema(),fragType,parentType)){const parentTypeStr=Object(inspect.a)(parentType),fragTypeStr=Object(inspect.a)(fragType);context.reportError(new GraphQLError.a(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,{nodes:node}))}},FragmentSpread(node){const fragName=node.name.value,fragType=function getFragmentType(context,name){const frag=context.getFragment(name);if(frag){const type=Object(typeFromAST.a)(context.getSchema(),frag.typeCondition);if(Object(type_definition.r)(type))return type}}(context,fragName),parentType=context.getParentType();if(fragType&&parentType&&!Object(typeComparators.a)(context.getSchema(),fragType,parentType)){const parentTypeStr=Object(inspect.a)(parentType),fragTypeStr=Object(inspect.a)(fragType);context.reportError(new GraphQLError.a(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,{nodes:node}))}}}},function NoFragmentCyclesRule(context){const visitedFrags=Object.create(null),spreadPath=[],spreadPathIndexByName=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition:node=>(detectCycleRecursive(node),!1)};function detectCycleRecursive(fragment){if(visitedFrags[fragment.name.value])return;const fragmentName=fragment.name.value;visitedFrags[fragmentName]=!0;const spreadNodes=context.getFragmentSpreads(fragment.selectionSet);if(0!==spreadNodes.length){spreadPathIndexByName[fragmentName]=spreadPath.length;for(const spreadNode of spreadNodes){const spreadName=spreadNode.name.value,cycleIndex=spreadPathIndexByName[spreadName];if(spreadPath.push(spreadNode),void 0===cycleIndex){const spreadFragment=context.getFragment(spreadName);spreadFragment&&detectCycleRecursive(spreadFragment)}else{const cyclePath=spreadPath.slice(cycleIndex),viaPath=cyclePath.slice(0,-1).map((s=>'"'+s.name.value+'"')).join(", ");context.reportError(new GraphQLError.a(`Cannot spread fragment "${spreadName}" within itself`+(""!==viaPath?` via ${viaPath}.`:"."),{nodes:cyclePath}))}spreadPath.pop()}spreadPathIndexByName[fragmentName]=void 0}}},function UniqueVariableNamesRule(context){return{OperationDefinition(operationNode){var _operationNode$variab;const seenVariableDefinitions=groupBy(null!==(_operationNode$variab=operationNode.variableDefinitions)&&void 0!==_operationNode$variab?_operationNode$variab:[],(node=>node.variable.name.value));for(const[variableName,variableNodes]of seenVariableDefinitions)variableNodes.length>1&&context.reportError(new GraphQLError.a(`There can be only one variable named "$${variableName}".`,{nodes:variableNodes.map((node=>node.variable.name))}))}}},function NoUndefinedVariablesRule(context){let variableNameDefined=Object.create(null);return{OperationDefinition:{enter(){variableNameDefined=Object.create(null)},leave(operation){const usages=context.getRecursiveVariableUsages(operation);for(const{node:node}of usages){const varName=node.name.value;!0!==variableNameDefined[varName]&&context.reportError(new GraphQLError.a(operation.name?`Variable "$${varName}" is not defined by operation "${operation.name.value}".`:`Variable "$${varName}" is not defined.`,{nodes:[node,operation]}))}}},VariableDefinition(node){variableNameDefined[node.variable.name.value]=!0}}},function NoUnusedVariablesRule(context){let variableDefs=[];return{OperationDefinition:{enter(){variableDefs=[]},leave(operation){const variableNameUsed=Object.create(null),usages=context.getRecursiveVariableUsages(operation);for(const{node:node}of usages)variableNameUsed[node.name.value]=!0;for(const variableDef of variableDefs){const variableName=variableDef.variable.name.value;!0!==variableNameUsed[variableName]&&context.reportError(new GraphQLError.a(operation.name?`Variable "$${variableName}" is never used in operation "${operation.name.value}".`:`Variable "$${variableName}" is never used.`,{nodes:variableDef}))}}},VariableDefinition(def){variableDefs.push(def)}}},KnownDirectivesRule,UniqueDirectivesPerLocationRule,function KnownArgumentNamesRule(context){return{...KnownArgumentNamesOnDirectivesRule(context),Argument(argNode){const argDef=context.getArgument(),fieldDef=context.getFieldDef(),parentType=context.getParentType();if(!argDef&&fieldDef&&parentType){const argName=argNode.name.value,knownArgsNames=fieldDef.args.map((arg=>arg.name)),suggestions=Object(suggestionList.a)(argName,knownArgsNames);context.reportError(new GraphQLError.a(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".`+Object(didYouMean.a)(suggestions),{nodes:argNode}))}}}},UniqueArgumentNamesRule,function ValuesOfCorrectTypeRule(context){return{ListValue(node){const type=Object(type_definition.p)(context.getParentInputType());if(!Object(type_definition.x)(type))return isValidValueNode(context,node),!1},ObjectValue(node){const type=Object(type_definition.o)(context.getInputType());if(!Object(type_definition.t)(type))return isValidValueNode(context,node),!1;const fieldNodeMap=Object(keyMap.a)(node.fields,(field=>field.name.value));for(const fieldDef of Object.values(type.getFields())){if(!fieldNodeMap[fieldDef.name]&&Object(type_definition.D)(fieldDef)){const typeStr=Object(inspect.a)(fieldDef.type);context.reportError(new GraphQLError.a(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,{nodes:node}))}}},ObjectField(node){const parentType=Object(type_definition.o)(context.getParentInputType());if(!context.getInputType()&&Object(type_definition.t)(parentType)){const suggestions=Object(suggestionList.a)(node.name.value,Object.keys(parentType.getFields()));context.reportError(new GraphQLError.a(`Field "${node.name.value}" is not defined by type "${parentType.name}".`+Object(didYouMean.a)(suggestions),{nodes:node}))}},NullValue(node){const type=context.getInputType();Object(type_definition.z)(type)&&context.reportError(new GraphQLError.a(`Expected value of type "${Object(inspect.a)(type)}", found ${Object(printer.a)(node)}.`,{nodes:node}))},EnumValue:node=>isValidValueNode(context,node),IntValue:node=>isValidValueNode(context,node),FloatValue:node=>isValidValueNode(context,node),StringValue:node=>isValidValueNode(context,node),BooleanValue:node=>isValidValueNode(context,node)}},function ProvidedRequiredArgumentsRule(context){return{...ProvidedRequiredArgumentsOnDirectivesRule(context),Field:{leave(fieldNode){var _fieldNode$arguments;const fieldDef=context.getFieldDef();if(!fieldDef)return!1;const providedArgs=new Set(null===(_fieldNode$arguments=fieldNode.arguments)||void 0===_fieldNode$arguments?void 0:_fieldNode$arguments.map((arg=>arg.name.value)));for(const argDef of fieldDef.args)if(!providedArgs.has(argDef.name)&&Object(type_definition.C)(argDef)){const argTypeStr=Object(inspect.a)(argDef.type);context.reportError(new GraphQLError.a(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,{nodes:fieldNode}))}}}}},function VariablesInAllowedPositionRule(context){let varDefMap=Object.create(null);return{OperationDefinition:{enter(){varDefMap=Object.create(null)},leave(operation){const usages=context.getRecursiveVariableUsages(operation);for(const{node:node,type:type,defaultValue:defaultValue}of usages){const varName=node.name.value,varDef=varDefMap[varName];if(varDef&&type){const schema=context.getSchema(),varType=Object(typeFromAST.a)(schema,varDef.type);if(varType&&!allowedVariableUsage(schema,varType,varDef.defaultValue,type,defaultValue)){const varTypeStr=Object(inspect.a)(varType),typeStr=Object(inspect.a)(type);context.reportError(new GraphQLError.a(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,{nodes:[varDef,node]}))}}}}},VariableDefinition(node){varDefMap[node.variable.name.value]=node}}},function OverlappingFieldsCanBeMergedRule(context){const comparedFragmentPairs=new PairSet,cachedFieldsAndFragmentNames=new Map;return{SelectionSet(selectionSet){const conflicts=function findConflictsWithinSelectionSet(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,parentType,selectionSet){const conflicts=[],[fieldMap,fragmentNames]=getFieldsAndFragmentNames(context,cachedFieldsAndFragmentNames,parentType,selectionSet);if(function collectConflictsWithin(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,fieldMap){for(const[responseName,fields]of Object.entries(fieldMap))if(fields.length>1)for(let i=0;i<fields.length;i++)for(let j=i+1;j<fields.length;j++){const conflict=findConflict(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,!1,responseName,fields[i],fields[j]);conflict&&conflicts.push(conflict)}}(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,fieldMap),0!==fragmentNames.length)for(let i=0;i<fragmentNames.length;i++){collectConflictsBetweenFieldsAndFragment(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,!1,fieldMap,fragmentNames[i]);for(let j=i+1;j<fragmentNames.length;j++)collectConflictsBetweenFragments(context,conflicts,cachedFieldsAndFragmentNames,comparedFragmentPairs,!1,fragmentNames[i],fragmentNames[j])}return conflicts}(context,cachedFieldsAndFragmentNames,comparedFragmentPairs,context.getParentType(),selectionSet);for(const[[responseName,reason],fields1,fields2]of conflicts){const reasonMsg=reasonMessage(reason);context.reportError(new GraphQLError.a(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:fields1.concat(fields2)}))}}}},UniqueInputFieldNamesRule]);Object.freeze([LoneSchemaDefinitionRule,UniqueOperationTypesRule,UniqueTypeNamesRule,UniqueEnumValueNamesRule,UniqueFieldDefinitionNamesRule,function UniqueArgumentDefinitionNamesRule(context){return{DirectiveDefinition(directiveNode){var _directiveNode$argume;const argumentNodes=null!==(_directiveNode$argume=directiveNode.arguments)&&void 0!==_directiveNode$argume?_directiveNode$argume:[];return checkArgUniqueness(`@${directiveNode.name.value}`,argumentNodes)},InterfaceTypeDefinition:checkArgUniquenessPerField,InterfaceTypeExtension:checkArgUniquenessPerField,ObjectTypeDefinition:checkArgUniquenessPerField,ObjectTypeExtension:checkArgUniquenessPerField};function checkArgUniquenessPerField(typeNode){var _typeNode$fields;const typeName=typeNode.name.value,fieldNodes=null!==(_typeNode$fields=typeNode.fields)&&void 0!==_typeNode$fields?_typeNode$fields:[];for(const fieldDef of fieldNodes){var _fieldDef$arguments;checkArgUniqueness(`${typeName}.${fieldDef.name.value}`,null!==(_fieldDef$arguments=fieldDef.arguments)&&void 0!==_fieldDef$arguments?_fieldDef$arguments:[])}return!1}function checkArgUniqueness(parentName,argumentNodes){const seenArgs=groupBy(argumentNodes,(arg=>arg.name.value));for(const[argName,argNodes]of seenArgs)argNodes.length>1&&context.reportError(new GraphQLError.a(`Argument "${parentName}(${argName}:)" can only be defined once.`,{nodes:argNodes.map((node=>node.name))}));return!1}},UniqueDirectiveNamesRule,KnownTypeNamesRule,KnownDirectivesRule,UniqueDirectivesPerLocationRule,PossibleTypeExtensionsRule,KnownArgumentNamesOnDirectivesRule,UniqueArgumentNamesRule,UniqueInputFieldNamesRule,ProvidedRequiredArgumentsOnDirectivesRule]);var devAssert=__webpack_require__("./node_modules/graphql/jsutils/devAssert.mjs"),language_visitor=__webpack_require__("./node_modules/graphql/language/visitor.mjs"),validate=__webpack_require__("./node_modules/graphql/type/validate.mjs"),TypeInfo=__webpack_require__("./node_modules/graphql/utilities/TypeInfo.mjs");class ValidationContext_ASTValidationContext{constructor(ast,onError){this._ast=ast,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=onError}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(error){this._onError(error)}getDocument(){return this._ast}getFragment(name){let fragments;if(this._fragments)fragments=this._fragments;else{fragments=Object.create(null);for(const defNode of this.getDocument().definitions)defNode.kind===kinds.a.FRAGMENT_DEFINITION&&(fragments[defNode.name.value]=defNode);this._fragments=fragments}return fragments[name]}getFragmentSpreads(node){let spreads=this._fragmentSpreads.get(node);if(!spreads){spreads=[];const setsToVisit=[node];let set;for(;set=setsToVisit.pop();)for(const selection of set.selections)selection.kind===kinds.a.FRAGMENT_SPREAD?spreads.push(selection):selection.selectionSet&&setsToVisit.push(selection.selectionSet);this._fragmentSpreads.set(node,spreads)}return spreads}getRecursivelyReferencedFragments(operation){let fragments=this._recursivelyReferencedFragments.get(operation);if(!fragments){fragments=[];const collectedNames=Object.create(null),nodesToVisit=[operation.selectionSet];let node;for(;node=nodesToVisit.pop();)for(const spread of this.getFragmentSpreads(node)){const fragName=spread.name.value;if(!0!==collectedNames[fragName]){collectedNames[fragName]=!0;const fragment=this.getFragment(fragName);fragment&&(fragments.push(fragment),nodesToVisit.push(fragment.selectionSet))}}this._recursivelyReferencedFragments.set(operation,fragments)}return fragments}}class SDLValidationContext extends ValidationContext_ASTValidationContext{constructor(ast,schema,onError){super(ast,onError),this._schema=schema}get[Symbol.toStringTag](){return"SDLValidationContext"}getSchema(){return this._schema}}class ValidationContext_ValidationContext extends ValidationContext_ASTValidationContext{constructor(schema,ast,typeInfo,onError){super(ast,onError),this._schema=schema,this._typeInfo=typeInfo,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(node){let usages=this._variableUsages.get(node);if(!usages){const newUsages=[],typeInfo=new TypeInfo.a(this._schema);Object(language_visitor.b)(node,Object(TypeInfo.b)(typeInfo,{VariableDefinition:()=>!1,Variable(variable){newUsages.push({node:variable,type:typeInfo.getInputType(),defaultValue:typeInfo.getDefaultValue()})}})),usages=newUsages,this._variableUsages.set(node,usages)}return usages}getRecursiveVariableUsages(operation){let usages=this._recursiveVariableUsages.get(operation);if(!usages){usages=this.getVariableUsages(operation);for(const frag of this.getRecursivelyReferencedFragments(operation))usages=usages.concat(this.getVariableUsages(frag));this._recursiveVariableUsages.set(operation,usages)}return usages}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function validate_validate(schema,documentAST,rules=specifiedRules,options,typeInfo=new TypeInfo.a(schema)){var _options$maxErrors;const maxErrors=null!==(_options$maxErrors=null==options?void 0:options.maxErrors)&&void 0!==_options$maxErrors?_options$maxErrors:100;documentAST||Object(devAssert.a)(!1,"Must provide document."),Object(validate.a)(schema);const abortObj=Object.freeze({}),errors=[],context=new ValidationContext_ValidationContext(schema,documentAST,typeInfo,(error=>{if(errors.length>=maxErrors)throw errors.push(new GraphQLError.a("Too many validation errors, error limit reached. Validation aborted.")),abortObj;errors.push(error)})),visitor=Object(language_visitor.c)(rules.map((rule=>rule(context))));try{Object(language_visitor.b)(documentAST,Object(TypeInfo.b)(typeInfo,visitor))}catch(e){if(e!==abortObj)throw e}return errors}var language_parser=__webpack_require__("./node_modules/graphql/language/parser.mjs");function NoDeprecatedCustomRule(context){return{Field(node){const fieldDef=context.getFieldDef(),deprecationReason=null==fieldDef?void 0:fieldDef.deprecationReason;if(fieldDef&&null!=deprecationReason){const parentType=context.getParentType();null!=parentType||Object(invariant.a)(!1),context.reportError(new GraphQLError.a(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,{nodes:node}))}},Argument(node){const argDef=context.getArgument(),deprecationReason=null==argDef?void 0:argDef.deprecationReason;if(argDef&&null!=deprecationReason){const directiveDef=context.getDirective();if(null!=directiveDef)context.reportError(new GraphQLError.a(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,{nodes:node}));else{const parentType=context.getParentType(),fieldDef=context.getFieldDef();null!=parentType&&null!=fieldDef||Object(invariant.a)(!1),context.reportError(new GraphQLError.a(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,{nodes:node}))}}},ObjectField(node){const inputObjectDef=Object(type_definition.o)(context.getParentInputType());if(Object(type_definition.t)(inputObjectDef)){const inputFieldDef=inputObjectDef.getFields()[node.name.value],deprecationReason=null==inputFieldDef?void 0:inputFieldDef.deprecationReason;null!=deprecationReason&&context.reportError(new GraphQLError.a(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,{nodes:node}))}},EnumValue(node){const enumValueDef=context.getEnumValue(),deprecationReason=null==enumValueDef?void 0:enumValueDef.deprecationReason;if(enumValueDef&&null!=deprecationReason){const enumTypeDef=Object(type_definition.o)(context.getInputType());null!=enumTypeDef||Object(invariant.a)(!1),context.reportError(new GraphQLError.a(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,{nodes:node}))}}}}var types_es=__webpack_require__("./node_modules/@graphiql/react/dist/types.es.js"),Range_es=__webpack_require__("./node_modules/@graphiql/react/dist/Range.es.js"),__defProp=(__webpack_require__("./node_modules/@graphiql/react/dist/index.es.js"),__webpack_require__("./node_modules/react/index.js"),__webpack_require__("./node_modules/react-dom/index.js"),Object.defineProperty),__name=(target,value)=>__defProp(target,"name",{value:value,configurable:!0});const lint_es_specifiedSDLRules=[LoneSchemaDefinitionRule,UniqueOperationTypesRule,UniqueTypeNamesRule,UniqueEnumValueNamesRule,UniqueFieldDefinitionNamesRule,UniqueDirectiveNamesRule,KnownTypeNamesRule,KnownDirectivesRule,UniqueDirectivesPerLocationRule,PossibleTypeExtensionsRule,UniqueArgumentNamesRule,UniqueInputFieldNamesRule];function validateWithCustomRules(schema,ast,customRules,isRelayCompatMode,isSchemaDocument){const rules=specifiedRules.filter((rule=>rule!==NoUnusedFragmentsRule&&rule!==ExecutableDefinitionsRule&&(!isRelayCompatMode||rule!==KnownFragmentNamesRule)));customRules&&Array.prototype.push.apply(rules,customRules),isSchemaDocument&&Array.prototype.push.apply(rules,lint_es_specifiedSDLRules);return validate_validate(schema,ast,rules).filter((error=>{if(-1!==error.message.indexOf("Unknown directive")&&error.nodes){const node=error.nodes[0];if(node&&node.kind===kinds.a.DIRECTIVE){const name=node.name.value;if("arguments"===name||"argumentDefinitions"===name)return!1}}return!0}))}__name(validateWithCustomRules,"validateWithCustomRules");const DIAGNOSTIC_SEVERITY={["Error"]:1,["Warning"]:2,["Information"]:3,["Hint"]:4},lint_es_invariant=__name(((condition,message)=>{if(!condition)throw new Error(message)}),"invariant");function getDiagnostics(query,schema=null,customRules,isRelayCompatMode,externalFragments){var _a,_b;let ast=null;externalFragments&&(query+="string"==typeof externalFragments?"\n\n"+externalFragments:"\n\n"+externalFragments.reduce(((agg,node)=>agg+=Object(printer.a)(node)+"\n\n"),""));try{ast=Object(language_parser.a)(query)}catch(error){if(error instanceof GraphQLError.a){const range=getRange(null!==(_b=null===(_a=error.locations)||void 0===_a?void 0:_a[0])&&void 0!==_b?_b:{line:0,column:0},query);return[{severity:DIAGNOSTIC_SEVERITY.Error,message:error.message,source:"GraphQL: Syntax",range:range}]}throw error}return validateQuery(ast,schema,customRules,isRelayCompatMode)}function validateQuery(ast,schema=null,customRules,isRelayCompatMode){if(!schema)return[];const validationErrorAnnotations=mapCat(validateWithCustomRules(schema,ast,customRules,isRelayCompatMode),(error=>annotations(error,DIAGNOSTIC_SEVERITY.Error,"Validation"))),deprecationWarningAnnotations=mapCat(validate_validate(schema,ast,[NoDeprecatedCustomRule]),(error=>annotations(error,DIAGNOSTIC_SEVERITY.Warning,"Deprecation")));return validationErrorAnnotations.concat(deprecationWarningAnnotations)}function mapCat(array,mapper){return Array.prototype.concat.apply([],array.map(mapper))}function annotations(error,severity,type){if(!error.nodes)return[];const highlightedNodes=[];return error.nodes.forEach((node=>{const highlightNode="Variable"!==node.kind&&"name"in node&&void 0!==node.name?node.name:"variable"in node&&void 0!==node.variable?node.variable:node;if(highlightNode){lint_es_invariant(error.locations,"GraphQL validation error requires locations.");const loc=error.locations[0],highlightLoc=getLocation(highlightNode),end=loc.column+(highlightLoc.end-highlightLoc.start);highlightedNodes.push({source:`GraphQL: ${type}`,message:error.message,severity:severity,range:new Range_es.c(new Range_es.b(loc.line-1,loc.column-1),new Range_es.b(loc.line-1,end))})}})),highlightedNodes}function getRange(location,queryText){const parser=Object(types_es.i)(),state=parser.startState(),lines=queryText.split("\n");lint_es_invariant(lines.length>=location.line,"Query text must have more lines than where the error happened");let stream=null;for(let i=0;i<location.line;i++)for(stream=new Range_es.a(lines[i]);!stream.eol();){if("invalidchar"===parser.token(stream,state))break}lint_es_invariant(stream,"Expected Parser stream to be available.");const line=location.line-1,start=stream.getStartOfToken(),end=stream.getCurrentPosition();return new Range_es.c(new Range_es.b(line,start),new Range_es.b(line,end))}function getLocation(node){const location=node.loc;return lint_es_invariant(location,"Expected ASTNode to have a location."),location}__name(getDiagnostics,"getDiagnostics"),__name(validateQuery,"validateQuery"),__name(mapCat,"mapCat"),__name(annotations,"annotations"),__name(getRange,"getRange"),__name(getLocation,"getLocation");const SEVERITY=["error","warning","information","hint"],TYPE={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};codemirror_es.C.registerHelper("lint","graphql",((text,options)=>getDiagnostics(text,options.schema,options.validationRules,void 0,options.externalFragments).map((error=>({message:error.message,severity:error.severity?SEVERITY[error.severity-1]:SEVERITY[0],type:error.source?TYPE[error.source]:void 0,from:codemirror_es.C.Pos(error.range.start.line,error.range.start.character),to:codemirror_es.C.Pos(error.range.end.line,error.range.end.character)})))))}}]);